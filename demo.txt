import numpy as np
from enum import Enum, auto
from typing import List, Tuple, Dict, Set, Optional, Union
from IPython.display import display, HTML, clear_output
import ipywidgets as widgets

# å®šæ•°ã¨åˆ—æŒ™å‹
class Player(Enum):
    BLACK = 0  # å…ˆæ‰‹ï¼ˆé»’ï¼‰
    WHITE = 1  # å¾Œæ‰‹ï¼ˆç™½ï¼‰

    @property
    def opponent(self):
        return Player.WHITE if self == Player.BLACK else Player.BLACK

class PieceType(Enum):
    SUI = auto()    # å¸¥ - ç‹å°†ã«ç›¸å½“
    DAI = auto()    # å¤§ - é£›è»Š+æ–œã‚ç§»å‹•
    CHUU = auto()   # ä¸­ - è§’è¡Œ+ç›´ç·šç§»å‹•
    SHO = auto()    # å° - é‡‘å°†ã«ç›¸å½“
    SAMURAI = auto() # ä¾ - å‰æ–¹ã€æ–œã‚å‰æ–¹ã€å¾Œæ–¹
    HYO = auto()    # å…µ - å‰/å¾Œæ–¹ã®æ­©å…µ
    UMA = auto()    # é¦¬ - 2ãƒã‚¹ç›´ç·šç§»å‹•
    SHINOBI = auto() # å¿ - 1ã€œ2ãƒã‚¹æ–œã‚ç§»å‹•
    YARI = auto()   # æ§ - ä¾ã¨ä¼¼ã¦ã„ã‚‹ãŒå‰ã«2ãƒã‚¹ç§»å‹•å¯
    TORIDE = auto()  # ç ¦ - é˜²å¾¡é§’
    YUMI = auto()   # å¼“ - é§’ã‚’é£›ã³è¶Šãˆå¯èƒ½
    TSUTU = auto()  # ç­’ - ãƒã‚¹ã‚±ãƒƒãƒˆï¼ˆé£›ã³è¶Šãˆé§’ï¼‰
    HOU = auto()    # ç ² - å¤§ç ²ï¼ˆé£›ã³è¶Šãˆé§’ï¼‰
    BOU = auto()    # è¬€ - ã‚¹ãƒ‘ã‚¤ï¼ˆæ•µé§’ã‚’å¯è¿”ã‚‰ã›ã‚‹ï¼‰

# å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é§’ã®æ•°
PIECE_COUNTS = {
    PieceType.SUI: 1,
    PieceType.DAI: 1,
    PieceType.CHUU: 1,
    PieceType.SHO: 2,
    PieceType.SAMURAI: 2,
    PieceType.HYO: 4,
    PieceType.UMA: 2,
    PieceType.SHINOBI: 2,
    PieceType.YARI: 3,
    PieceType.TORIDE: 2,
    PieceType.YUMI: 2,
    PieceType.TSUTU: 1,
    PieceType.HOU: 1,
    PieceType.BOU: 1
}

# ç›¤é¢ã®è¨­å®š
BOARD_SIZE = 9
MAX_STACK_HEIGHT = 3

class Piece:
    """è»è­°ã®é§’ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹"""
    def __init__(self, piece_type: PieceType, owner: Player):
        self.piece_type = piece_type
        self.owner = owner

    def __str__(self):
        """é§’ã®æ–‡å­—åˆ—è¡¨ç¾"""
        piece_symbols = {
            PieceType.SUI: "å¸¥",
            PieceType.DAI: "å¤§",
            PieceType.CHUU: "ä¸­",
            PieceType.SHO: "å°",
            PieceType.SAMURAI: "ä¾",
            PieceType.HYO: "å…µ",
            PieceType.UMA: "é¦¬",
            PieceType.SHINOBI: "å¿",
            PieceType.YARI: "æ§",
            PieceType.TORIDE: "ç ¦",
            PieceType.YUMI: "å¼“",
            PieceType.TSUTU: "ç­’",
            PieceType.HOU: "ç ²",
            PieceType.BOU: "è¬€"
        }
        return f"{'b' if self.owner == Player.BLACK else 'w'}{piece_symbols[self.piece_type]}"

    def get_possible_moves(self, position: Tuple[int, int], board: 'Board', stack_level: int) -> List[Tuple[int, int]]:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã‹ã‚‰ã“ã®é§’ã®å…¨ã¦ã®å¯èƒ½ãªç§»å‹•å…ˆã‚’è¿”ã™"""
        row, col = position
        possible_moves = []

        # å„é§’ã‚¿ã‚¤ãƒ—ã”ã¨ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®šç¾©
        if self.piece_type == PieceType.SUI:  # å¸¥ã®ç§»å‹•ï¼ˆç‹å°†ã®ã‚ˆã†ãªå‹•ãï¼‰
            directions = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        elif self.piece_type == PieceType.DAI:  # å¤§å°†ã®ç§»å‹•ï¼ˆé£›è»Š + 1ãƒã‚¹æ–œã‚ï¼‰
            # ç›´ç·šç§»å‹•ï¼ˆç„¡åˆ¶é™ï¼‰
            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                r, c = row, col
                while True:
                    r, c = r + dr, c + dc
                    if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE):
                        break
                    if board.is_occupied((r, c)):
                        possible_moves.append((r, c))
                        break
                    possible_moves.append((r, c))

            # æ–œã‚ç§»å‹•ï¼ˆ1ãƒã‚¹ï¼‰
            for dr, dc in [(1, 1), (-1, 1), (-1, -1), (1, -1)]:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        elif self.piece_type == PieceType.CHUU:  # ä¸­å°†ã®ç§»å‹•ï¼ˆè§’è¡Œ + 1ãƒã‚¹ç›´ç·šï¼‰
            # æ–œã‚ç§»å‹•ï¼ˆç„¡åˆ¶é™ï¼‰
            for dr, dc in [(1, 1), (-1, 1), (-1, -1), (1, -1)]:
                r, c = row, col
                while True:
                    r, c = r + dr, c + dc
                    if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE):
                        break
                    if board.is_occupied((r, c)):
                        possible_moves.append((r, c))
                        break
                    possible_moves.append((r, c))

            # ç›´ç·šç§»å‹•ï¼ˆ1ãƒã‚¹ï¼‰
            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        elif self.piece_type == PieceType.SHO:  # å°å°†ã®ç§»å‹•ï¼ˆé‡‘å°†ã¨åŒæ§˜ï¼‰
            directions = [(1, 0), (1, 1), (0, 1), (0, -1), (-1, 0), (1, -1)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        elif self.piece_type == PieceType.SAMURAI:  # ä¾ã®ç§»å‹•ï¼ˆå‰æ–¹ã€æ–œã‚å‰æ–¹ã€å¾Œæ–¹ï¼‰
            directions = [(1, 0), (1, 1), (1, -1), (-1, 0)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        elif self.piece_type == PieceType.HYO:  # å…µã®ç§»å‹•ï¼ˆå‰å¾Œã®æ­©å…µï¼‰
            directions = [(1, 0), (-1, 0)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        elif self.piece_type == PieceType.UMA:  # é¦¬ã®ç§»å‹•ï¼ˆ2ãƒã‚¹ç›´ç·šç§»å‹•ï¼‰
            directions = [(2, 0), (0, 2), (-2, 0), (0, -2)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    # çµŒè·¯ãŒç©ºã„ã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆé£›ã³è¶Šãˆãªã—ï¼‰
                    mid_r, mid_c = row + dr//2, col + dc//2
                    if not board.is_occupied((mid_r, mid_c)):
                        possible_moves.append((r, c))

        elif self.piece_type == PieceType.SHINOBI:  # å¿ã®ç§»å‹•ï¼ˆ1ã€œ2ãƒã‚¹æ–œã‚ç§»å‹•ï¼‰
            # 1ãƒã‚¹æ–œã‚ç§»å‹•
            for dr, dc in [(1, 1), (-1, 1), (-1, -1), (1, -1)]:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

            # 2ãƒã‚¹æ–œã‚ç§»å‹•
            for dr, dc in [(2, 2), (-2, 2), (-2, -2), (2, -2)]:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    # çµŒè·¯ãŒç©ºã„ã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆé£›ã³è¶Šãˆãªã—ï¼‰
                    mid_r, mid_c = row + dr//2, col + dc//2
                    if not board.is_occupied((mid_r, mid_c)):
                        possible_moves.append((r, c))

        elif self.piece_type == PieceType.YARI:  # æ§ã®ç§»å‹•ï¼ˆå‰æ–¹2ãƒã‚¹å¯èƒ½ãªä¾ï¼‰
            # ä¾ã¨åŒæ§˜ã ãŒã€å‰æ–¹ã®ç§»å‹•ãŒæ‹¡å¼µ
            directions = [(1, 1), (1, -1), (-1, 0)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

            # å‰æ–¹1-2ãƒã‚¹
            for steps in [1, 2]:
                r, c = row + steps, col
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    if steps == 1 or not board.is_occupied((row + 1, col)):
                        possible_moves.append((r, c))

        elif self.piece_type == PieceType.TORIDE:  # ç ¦ã®ç§»å‹•ï¼ˆé˜²å¾¡é§’ï¼‰
            # åŸºæœ¬çš„ãªé˜²å¾¡çš„ç§»å‹• - ã“ã®å®Ÿè£…ã§ã¯ç°¡ç•¥åŒ–
            directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        elif self.piece_type == PieceType.YUMI:  # å¼“ã®ç§»å‹•ï¼ˆé£›ã³è¶Šãˆèƒ½åŠ›ï¼‰
            # ç›´ç·šä¸Šã§1ã¤ã®é§’ã‚’é£›ã³è¶Šãˆã‚‰ã‚Œã‚‹
            directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
            for dr, dc in directions:
                # 1ãƒã‚¹ç§»å‹•
                r1, c1 = row + dr, col + dc
                if 0 <= r1 < BOARD_SIZE and 0 <= c1 < BOARD_SIZE:
                    possible_moves.append((r1, c1))

                    # 1ãƒã‚¹å…ˆã«é§’ãŒã‚ã‚Œã°ã€2ãƒã‚¹å…ˆã«é£›ã³è¶Šãˆã‚‰ã‚Œã‚‹
                    if board.is_occupied((r1, c1)):
                        r2, c2 = r1 + dr, c1 + dc
                        if 0 <= r2 < BOARD_SIZE and 0 <= c2 < BOARD_SIZE:
                            possible_moves.append((r2, c2))

        elif self.piece_type == PieceType.TSUTU:  # ç­’ã®ç§»å‹•ï¼ˆé£›ã³è¶Šãˆèƒ½åŠ›ï¼‰
            # ç›´äº¤æ–¹å‘ã®ä»»æ„ã®é§’ã‚’1ã¤é£›ã³è¶Šãˆã‚‰ã‚Œã‚‹
            directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
            for dr, dc in directions:
                # 1ãƒã‚¹ç§»å‹•
                r1, c1 = row + dr, col + dc
                if 0 <= r1 < BOARD_SIZE and 0 <= c1 < BOARD_SIZE:
                    possible_moves.append((r1, c1))

                    # 1ãƒã‚¹å…ˆã«é§’ãŒã‚ã‚Œã°ã€2ãƒã‚¹å…ˆã«é£›ã³è¶Šãˆã‚‰ã‚Œã‚‹
                    if board.is_occupied((r1, c1)):
                        r2, c2 = r1 + dr, c1 + dc
                        if 0 <= r2 < BOARD_SIZE and 0 <= c2 < BOARD_SIZE:
                            possible_moves.append((r2, c2))

        elif self.piece_type == PieceType.HOU:  # ç ²ã®ç§»å‹•ï¼ˆé£›ã³è¶Šãˆèƒ½åŠ›ï¼‰
            # TSTUTUã«ä¼¼ã¦ã„ã‚‹ãŒã•ã‚‰ã«é ãã¸ã‚¸ãƒ£ãƒ³ãƒ—å¯èƒ½
            directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
            for dr, dc in directions:
                # 1ãƒã‚¹ç§»å‹•
                r1, c1 = row + dr, col + dc
                if 0 <= r1 < BOARD_SIZE and 0 <= c1 < BOARD_SIZE:
                    possible_moves.append((r1, c1))

                    # 1ãƒã‚¹å…ˆã«é§’ãŒã‚ã‚Œã°ã€2ãƒã‚¹å…ˆã«é£›ã³è¶Šãˆã‚‰ã‚Œã‚‹
                    if board.is_occupied((r1, c1)):
                        r2, c2 = r1 + dr, c1 + dc
                        if 0 <= r2 < BOARD_SIZE and 0 <= c2 < BOARD_SIZE:
                            possible_moves.append((r2, c2))

        elif self.piece_type == PieceType.BOU:  # è¬€ã®ç§»å‹•ï¼ˆã‚¹ãƒ‘ã‚¤ï¼‰
            # éŠ€å°†ã®ã‚ˆã†ãªå‹•ãã ãŒçœŸã£ç›´ãå‰ã«ã¯é€²ã‚ãªã„
            directions = [(1, 1), (1, -1), (-1, 0), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                r, c = row + dr, col + dc
                if 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
                    possible_moves.append((r, c))

        # ã‚¹ã‚¿ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«ãƒ«ãƒ¼ãƒ«ã«åŸºã¥ã„ã¦ç§»å‹•ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        valid_moves = []
        for move in possible_moves:
            # ã‚¹ã‚¿ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«ãƒ«ãƒ¼ãƒ«ã«åŸºã¥ã„ã¦ç§»å‹•ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
            top_level_at_target = board.get_top_stack_level(move)

            # ç©ºã®ãƒã‚¹ã«ã¯å¸¸ã«ç§»å‹•å¯èƒ½
            if top_level_at_target == 0:
                valid_moves.append(move)
            # åŒã˜ã‹ä½ã„ãƒ¬ãƒ™ãƒ«ã«ã¯æ•ç²/ã‚¹ã‚¿ãƒƒã‚¯å¯èƒ½
            elif top_level_at_target <= stack_level:
                top_owner = board.get_top_piece_owner(move)
                # ç›¸æ‰‹ã®é§’ã‹åŒã˜ãƒ¬ãƒ™ãƒ«ãªã‚‰æ•ç²/ã‚¹ã‚¿ãƒƒã‚¯å¯èƒ½
                if top_owner != self.owner or top_level_at_target < stack_level:
                    valid_moves.append(move)

        return valid_moves

class Stack:
    """ç›¤é¢ã®ä¸€ã¤ã®ä½ç½®ã«ã‚ã‚‹ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆé‡ã­é§’ï¼‰ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹"""
    def __init__(self):
        self.pieces = []  # ä¸‹ã‹ã‚‰ä¸Šã¸ã®é§’ã®ãƒªã‚¹ãƒˆ

    def __len__(self):
        return len(self.pieces)

    def is_empty(self):
        return len(self.pieces) == 0

    def add_piece(self, piece: Piece) -> bool:
        """ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€ç•ªä¸Šã«é§’ã‚’è¿½åŠ ã€‚æˆåŠŸã™ã‚Œã°True"""
        if len(self.pieces) >= MAX_STACK_HEIGHT:
            return False
        self.pieces.append(piece)
        return True

    def remove_top_piece(self) -> Optional[Piece]:
        """ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ä¸€ç•ªä¸Šã®é§’ã‚’å–ã‚Šé™¤ãã€è¿”ã™"""
        if self.is_empty():
            return None
        return self.pieces.pop()

    def get_top_piece(self) -> Optional[Piece]:
        """å–ã‚Šé™¤ã‹ãšã«ä¸€ç•ªä¸Šã®é§’ã‚’è¿”ã™"""
        if self.is_empty():
            return None
        return self.pieces[-1]

    def get_piece_at_level(self, level: int) -> Optional[Piece]:
        """æŒ‡å®šã•ã‚ŒãŸã‚¹ã‚¿ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«ã®é§’ã‚’è¿”ã™ï¼ˆ0ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰"""
        if level < 0 or level >= len(self.pieces):
            return None
        return self.pieces[level]

    def convert_piece_at_level(self, level: int, new_owner: Player) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ã®é§’ã®æ‰€æœ‰è€…ã‚’å¤‰æ›´ï¼ˆå¯è¿”ã‚Šèƒ½åŠ›ç”¨ï¼‰"""
        if level < 0 or level >= len(self.pieces):
            return False
        self.pieces[level].owner = new_owner
        return True

    def __str__(self):
        if self.is_empty():
            return "   "
        return "/".join(str(piece) for piece in self.pieces)

class Board:
    """è»è­°ã®ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹"""
    def __init__(self):
        # ç©ºã®ç›¤é¢ã‚’åˆæœŸåŒ–
        self.stacks = [[Stack() for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]

    def get_stack(self, position: Tuple[int, int]) -> Stack:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚’è¿”ã™"""
        row, col = position
        return self.stacks[row][col]

    def is_occupied(self, position: Tuple[int, int]) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã«å°‘ãªãã¨ã‚‚1ã¤ã®é§’ãŒã‚ã‚‹ã‹ç¢ºèª"""
        return not self.get_stack(position).is_empty()

    def get_top_stack_level(self, position: Tuple[int, int]) -> int:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã®ã‚¹ã‚¿ãƒƒã‚¯ã®ç¾åœ¨ã®é«˜ã•ã‚’è¿”ã™ï¼ˆç©ºãªã‚‰0ï¼‰"""
        return len(self.get_stack(position))

    def get_top_piece(self, position: Tuple[int, int]) -> Optional[Piece]:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã®ä¸€ç•ªä¸Šã®é§’ã‚’è¿”ã™"""
        return self.get_stack(position).get_top_piece()

    def get_top_piece_owner(self, position: Tuple[int, int]) -> Optional[Player]:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã®ä¸€ç•ªä¸Šã®é§’ã®æ‰€æœ‰è€…ã‚’è¿”ã™"""
        piece = self.get_top_piece(position)
        return piece.owner if piece else None

    def add_piece(self, position: Tuple[int, int], piece: Piece) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã®ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€ç•ªä¸Šã«é§’ã‚’è¿½åŠ """
        return self.get_stack(position).add_piece(piece)

    def remove_top_piece(self, position: Tuple[int, int]) -> Optional[Piece]:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ã‹ã‚‰ä¸€ç•ªä¸Šã®é§’ã‚’å–ã‚Šé™¤ãã€è¿”ã™"""
        return self.get_stack(position).remove_top_piece()

    def move_piece(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int],
                  check_only: bool = False) -> bool:
        """ã‚ã‚‹ä½ç½®ã‹ã‚‰åˆ¥ã®ä½ç½®ã«é§’ã‚’ç§»å‹•"""
        if not self.is_occupied(from_pos):
            return False

        from_stack = self.get_stack(from_pos)
        to_stack = self.get_stack(to_pos)

        # ç›®æ¨™ã‚¹ã‚¿ãƒƒã‚¯ãŒã™ã§ã«æœ€å¤§é«˜ã•ã®å ´åˆã¯ç§»å‹•ä¸å¯
        if len(to_stack) >= MAX_STACK_HEIGHT:
            return False

        # ãƒã‚§ãƒƒã‚¯ã®ã¿ã®å ´åˆã¯å®Ÿéš›ã«ç§»å‹•ã—ãªã„
        if check_only:
            return True

        # å…ƒã®ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰é§’ã‚’å–ã‚Šé™¤ãã€ç›®æ¨™ã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ 
        piece = from_stack.remove_top_piece()
        to_stack.add_piece(piece)

        return True

    def __str__(self):
        """ç›¤é¢ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã™"""
        # å„ã‚»ãƒ«ã®å¹…ã‚’å®šç¾©ï¼ˆåŠè§’5æ–‡å­—ï¼‰
        cell_width = 5

        # åŒºåˆ‡ã‚Šç·šã®é•·ã•ã‚’è¨ˆç®—
        separator_length = BOARD_SIZE * (cell_width + 1) + 1

        result = []

        # åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼
        header = "   "
        for i in range(BOARD_SIZE):
            # å„ã‚»ãƒ«ã®ä¸­å¤®ã«åˆ—ç•ªå·ã‚’é…ç½®
            header += f"{i:^{cell_width}}|"
        result.append(header)

        # åŒºåˆ‡ã‚Šç·š
        result.append("  " + "-" * separator_length)

        for row in range(BOARD_SIZE):
            row_str = f"{row} |"
            for col in range(BOARD_SIZE):
                stack = self.stacks[row][col]
                if stack.is_empty():
                    # ç©ºã®ã‚»ãƒ«
                    row_str += " " * cell_width + "|"
                else:
                    # é§’ãŒã‚ã‚‹ã‚»ãƒ« - ä¸­å¤®ã«é…ç½®
                    piece_str = str(stack.get_top_piece())
                    row_str += f"{piece_str:^{cell_width - 1}}|"
            result.append(row_str)
            result.append("  " + "-" * separator_length)

        return "\n".join(result)

class HumanPlayer:
    """ã‚²ãƒ¼ãƒ å†…ã®äººé–“ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹"""
    def __init__(self, color: Player):
        self.color = color
        self.unplaced_pieces = {}

        # æœªé…ç½®ã®é§’ã‚»ãƒƒãƒˆã‚’åˆæœŸåŒ–
        for piece_type, count in PIECE_COUNTS.items():
            self.unplaced_pieces[piece_type] = count

    def get_unplaced_count(self, piece_type: PieceType) -> int:
        """æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã®æ•°ã‚’è¿”ã™"""
        return self.unplaced_pieces.get(piece_type, 0)

    def decrement_unplaced(self, piece_type: PieceType) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã®æ•°ã‚’æ¸›ã‚‰ã™"""
        if self.get_unplaced_count(piece_type) <= 0:
            return False
        self.unplaced_pieces[piece_type] -= 1
        return True

    def increment_unplaced(self, piece_type: PieceType) -> None:
        """æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã®æ•°ã‚’å¢—ã‚„ã™"""
        self.unplaced_pieces[piece_type] = self.get_unplaced_count(piece_type) + 1

    def has_spy_conversion_available(self, enemy_piece_type: PieceType) -> bool:
        """ã‚¹ãƒ‘ã‚¤å¤‰æ›ã«ä½¿ç”¨å¯èƒ½ãªæœªé…ç½®é§’ãŒã‚ã‚‹ã‹ç¢ºèª"""
        return self.get_unplaced_count(enemy_piece_type) > 0

class GamePhase(Enum):
    SETUP = auto()  # åˆæœŸé…ç½®ãƒ•ã‚§ãƒ¼ã‚º
    PLAY = auto()   # ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚º

class Game:
    """è»è­°ã®ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã‚¯ãƒ©ã‚¹"""
    def __init__(self):
        self.board = Board()
        self.players = {
            Player.BLACK: HumanPlayer(Player.BLACK),
            Player.WHITE: HumanPlayer(Player.WHITE)
        }
        self.current_player = Player.BLACK  # é»’ï¼ˆå…ˆæ‰‹ï¼‰ãŒæœ€åˆ
        self.phase = GamePhase.SETUP
        self.move_count = 0
        self.sui_positions = {Player.BLACK: None, Player.WHITE: None}
        self.setup_complete = {Player.BLACK: False, Player.WHITE: False}
        # å¸¥ãŒå–ã‚‰ã‚ŒãŸã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
        self._captured_sui = False
        # å‹è€…
        self._winner = None

    def switch_turn(self):
        """ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹"""
        self.current_player = self.current_player.opponent
        self.move_count += 1

    def is_setup_complete(self) -> bool:
        """ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒåˆæœŸé…ç½®ã‚’å®Œäº†ã—ãŸã‹ç¢ºèª"""
        return self.setup_complete[Player.BLACK] and self.setup_complete[Player.WHITE]

    # Game ã‚¯ãƒ©ã‚¹ã® place_piece ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£
    def place_piece(self, position: Tuple[int, int], piece_type: PieceType) -> bool:
        """ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«é§’ã‚’é…ç½®"""
        if self.phase != GamePhase.SETUP:
            return False

        row, col = position
        player = self.players[self.current_player]

        # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã“ã®ã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã‚’æŒã£ã¦ã„ã‚‹ã‹ç¢ºèª
        if player.get_unplaced_count(piece_type) <= 0:
            return False

        # é…ç½®ä½ç½®ãŒæœ‰åŠ¹ã‹ç¢ºèª - ä¿®æ­£: é»’ã¨ç™½ã®æ¡ä»¶ã‚’é€†ã«ã—ã¦ã„ãŸå¯èƒ½æ€§
        if self.current_player == Player.BLACK:
            # é»’ã®é ˜åŸŸã¯ä¸‹ã‹ã‚‰3è¡Œ (6-8)
            if row < 6:
                return False
        else:  # Player.WHITE
            # ç™½ã®é ˜åŸŸã¯ä¸Šã‹ã‚‰3è¡Œ (0-2)
            if row > 2:
                return False

        # ä½ç½®ãŒç©ºã„ã¦ã„ã‚‹ã‹ç¢ºèª
        if self.board.is_occupied(position):
            return False

        # æœ€åˆã®æ‰‹ã¯å¿…ãšå¸¥ï¼ˆç‹ï¼‰ã‚’é…ç½®
        if (self.move_count == 0 and self.current_player == Player.BLACK) or \
           (self.move_count == 1 and self.current_player == Player.WHITE):
            if piece_type != PieceType.SUI:
                return False

        # é§’ã‚’é…ç½®
        piece = Piece(piece_type, self.current_player)
        success = self.board.add_piece(position, piece)

        if success:
            player.decrement_unplaced(piece_type)

            # ã“ã‚ŒãŒå¸¥ï¼ˆç‹ï¼‰ãªã‚‰ã€ãã®ä½ç½®ã‚’è¨˜éŒ²
            if piece_type == PieceType.SUI:
                self.sui_positions[self.current_player] = position

            self.switch_turn()
            return True

        return False

    def declare_setup_complete(self) -> bool:
        """ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é…ç½®å®Œäº†ã‚’å®£è¨€"""
        if self.phase != GamePhase.SETUP:
            return False

        # ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é…ç½®ã‚’å®Œäº†ã¨ã—ã¦ãƒãƒ¼ã‚¯
        self.setup_complete[self.current_player] = True

        # ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé…ç½®ã‚’å®Œäº†ã—ãŸã‚‰ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œ
        if self.is_setup_complete():
            self.phase = GamePhase.PLAY

        self.switch_turn()
        return True

    # å¸¥ï¼ˆç‹ï¼‰ãŒå–ã‚‰ã‚ŒãŸã‚‰ãã®æ™‚ç‚¹ã§å‹æ•—ãŒæ±ºã¾ã‚‹ã‚ˆã†ã«ã™ã‚‹
    def move_piece(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> bool:
        """ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«é§’ã‚’ç§»å‹•"""
        if self.phase != GamePhase.PLAY:
            return False

        # å…ƒã®ä½ç½®ã«é§’ãŒã‚ã‚‹ã‹ç¢ºèª
        if not self.board.is_occupied(from_pos):
            return False

        # å…ƒã®ä½ç½®ã®ä¸€ç•ªä¸Šã®é§’ãŒç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚‚ã®ã‹ç¢ºèª
        top_piece = self.board.get_top_piece(from_pos)
        if top_piece.owner != self.current_player:
            return False

        # ç§»å‹•ã™ã‚‹é§’ã®ã‚¹ã‚¿ãƒƒã‚¯ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
        stack_level = self.board.get_top_stack_level(from_pos)

        # é§’ã®ç§»å‹•ãƒ«ãƒ¼ãƒ«ã«å¾“ã£ã¦ç§»å‹•ãŒæœ‰åŠ¹ã‹ç¢ºèª
        possible_moves = top_piece.get_possible_moves(from_pos, self.board, stack_level)
        if to_pos not in possible_moves:
            return False

        # ã‚¹ã‚¿ãƒƒã‚¯é«˜ã•ãƒ«ãƒ¼ãƒ«ã‚’ç¢ºèª
        from_stack_height = self.board.get_top_stack_level(from_pos)
        to_stack_height = self.board.get_top_stack_level(to_pos)

        # MAX_STACK_HEIGHTä»¥ä¸Šã¯ç©ã‚ãªã„
        if to_stack_height >= MAX_STACK_HEIGHT:
            return False

        # ç§»å‹•å…ˆã«æ•µã®å¸¥ãŒã‚ã‚‹ã‹ç¢ºèªï¼ˆå‹åˆ©æ¡ä»¶ï¼‰
        target_is_enemy_sui = False
        if self.board.is_occupied(to_pos):
            target_piece = self.board.get_top_piece(to_pos)
            if target_piece.owner != self.current_player and target_piece.piece_type == PieceType.SUI:
                target_is_enemy_sui = True
                # æ•µã®å¸¥ã®ä½ç½®æƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                self.sui_positions[target_piece.owner] = None

        # è¬€ï¼ˆã‚¹ãƒ‘ã‚¤ï¼‰ã®ç‰¹æ®Šã‚±ãƒ¼ã‚¹ - å¯è¿”ã‚Šï¼ˆå¯è¿”ã‚Šã®ç‰¹æ®Šèƒ½åŠ›ï¼‰
        spy_conversion = False
        if top_piece.piece_type == PieceType.BOU:
            # æ•µã®é§’ã«ç§»å‹•ã™ã‚‹å ´åˆã€å¤‰æ›ãŒå¯èƒ½ã‹ç¢ºèª
            if self.board.is_occupied(to_pos):
                target_piece = self.board.get_top_piece(to_pos)
                if target_piece.owner != self.current_player:
                    # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒåŒã˜ã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã‚’æŒã£ã¦ã„ã‚‹ã‹ç¢ºèª
                    player = self.players[self.current_player]
                    if player.has_spy_conversion_available(target_piece.piece_type) and target_piece.piece_type != PieceType.SUI:
                        # å¸¥ã¯å¯è¿”ã‚‰ã›ãªã„
                        spy_conversion = True

        # ç§»å‹•ã‚’å®Ÿè¡Œ
        success = self.board.move_piece(from_pos, to_pos)

        if success:
            # ã‚¹ãƒ‘ã‚¤å¤‰æ›ãŒé©ç”¨å¯èƒ½ãªã‚‰å‡¦ç†
            if spy_conversion:
                # ã‚¹ãƒ‘ã‚¤ã®ä¸‹ã®é§’ã‚’å¤‰æ›
                target_stack = self.board.get_stack(to_pos)
                if len(target_stack) >= 2:
                    target_piece_level = len(target_stack) - 2  # ã‚¹ãƒ‘ã‚¤ã®ä¸‹ã®é§’
                    target_piece = target_stack.get_piece_at_level(target_piece_level)
                    target_piece_type = target_piece.piece_type

                    # é§’ã‚’å¤‰æ›
                    target_stack.convert_piece_at_level(target_piece_level, self.current_player)

                    # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœªé…ç½®é§’ã‚’æ›´æ–°
                    player = self.players[self.current_player]
                    player.decrement_unplaced(target_piece_type)

            # å¸¥ã‚’ç§»å‹•ã—ãŸå ´åˆã¯ä½ç½®ã‚’æ›´æ–°
            if top_piece.piece_type == PieceType.SUI:
                self.sui_positions[self.current_player] = to_pos

            # å¸¥ã‚’å–ã£ãŸå ´åˆã¯ç‰¹åˆ¥ãªå‡¦ç†ï¼ˆã™ãã«å‹æ•—ãŒæ±ºã¾ã‚‹ï¼‰
            if target_is_enemy_sui:
                self._captured_sui = True
                self._winner = self.current_player
            else:
                self.switch_turn()
            return True

        return False


    def place_new_piece(self, position: Tuple[int, int], piece_type: PieceType) -> bool:
        """ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«æ–°ã—ã„é§’ã‚’é…ç½®"""
        if self.phase != GamePhase.PLAY:
            return False

        player = self.players[self.current_player]

        # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã“ã®ã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã‚’æŒã£ã¦ã„ã‚‹ã‹ç¢ºèª
        if player.get_unplaced_count(piece_type) <= 0:
            return False

        # ä½ç½®ãŒç©ºã„ã¦ã„ã‚‹ã‹ç¢ºèª
        if self.board.is_occupied(position):
            return False

        # ä½ç½®ãŒæœ‰åŠ¹ã‹ç¢ºèªï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‰ç·šã‚ˆã‚Šå…ˆã«ã¯é…ç½®ä¸å¯ï¼‰
        frontline = self.get_frontline(self.current_player)
        if self.current_player == Player.BLACK:
            # é»’ã®é§’ã¯å‰ç·šä»¥é™ã«ã®ã¿é…ç½®å¯èƒ½
            if position[0] < frontline:
                return False
        else:  # Player.WHITE
            # ç™½ã®é§’ã¯å‰ç·šä»¥é™ã«ã®ã¿é…ç½®å¯èƒ½
            if position[0] > frontline:
                return False

        # é§’ã‚’é…ç½®
        piece = Piece(piece_type, self.current_player)
        success = self.board.add_piece(position, piece)

        if success:
            player.decrement_unplaced(piece_type)

            # ã“ã‚ŒãŒå¸¥ï¼ˆç‹ï¼‰ãªã‚‰ã€ãã®ä½ç½®ã‚’è¨˜éŒ²
            if piece_type == PieceType.SUI:
                self.sui_positions[self.current_player] = position

            self.switch_turn()
            return True

        return False

    def get_frontline(self, player: Player) -> int:
        """æŒ‡å®šã•ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‰ç·šè¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—"""
        if player == Player.BLACK:
            # æœ€ã‚‚é€²ã‚“ã é»’ã®é§’ã‚’æ¢ã™
            for row in range(BOARD_SIZE):
                for col in range(BOARD_SIZE):
                    if self.board.is_occupied((row, col)) and self.board.get_top_piece_owner((row, col)) == Player.BLACK:
                        return row
            return BOARD_SIZE - 1  # é§’ãŒãªã„å ´åˆã¯æœ€å¾Œã®è¡Œã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹
        else:  # Player.WHITE
            # æœ€ã‚‚é€²ã‚“ã ç™½ã®é§’ã‚’æ¢ã™
            for row in range(BOARD_SIZE - 1, -1, -1):
                for col in range(BOARD_SIZE):
                    if self.board.is_occupied((row, col)) and self.board.get_top_piece_owner((row, col)) == Player.WHITE:
                        return row
            return 0  # é§’ãŒãªã„å ´åˆã¯æœ€åˆã®è¡Œã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹

    def is_checkmate(self) -> bool:
        """ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè©°ã¿ã®çŠ¶æ…‹ã‹ç¢ºèª"""
        # ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¸¥ã®ä½ç½®ã‚’å–å¾—
        sui_position = self.sui_positions[self.current_player]
        if sui_position is None:
            return False

        # å¸¥ãŒæ”»æ’ƒã‚’å—ã‘ã¦ã„ã‚‹ã‹ç¢ºèª
        if not self.is_position_under_attack(sui_position, self.current_player):
            return False

        # å¸¥ãŒé€ƒã’ã‚‰ã‚Œã‚‹ã‹ç¢ºèª
        sui_piece = self.board.get_top_piece(sui_position)
        sui_level = self.board.get_top_stack_level(sui_position)
        possible_moves = sui_piece.get_possible_moves(sui_position, self.board, sui_level)

        for move in possible_moves:
            # ä¸€æ™‚çš„ã«ç§»å‹•
            old_to_piece = self.board.get_top_piece(move)
            success = self.board.move_piece(sui_position, move, check_only=True)
            if success:
                # ç§»å‹•å¾Œã‚‚å¸¥ãŒæ”»æ’ƒã‚’å—ã‘ã¦ã„ã‚‹ã‹ç¢ºèª
                under_attack = self.is_position_under_attack(move, self.current_player)

                # ç§»å‹•ã‚’å…ƒã«æˆ»ã™
                self.board.remove_top_piece(move)
                if old_to_piece:
                    self.board.add_piece(move, old_to_piece)
                self.board.add_piece(sui_position, sui_piece)

                if not under_attack:
                    return False  # ç‹æ‰‹ã‚’é€ƒã‚Œã‚‹æ‰‹ãŒè¦‹ã¤ã‹ã£ãŸ

        # ç‹æ‰‹ã‚’é€ƒã‚Œã‚‹æ‰‹ãŒãªã„
        return True

    def is_position_under_attack(self, position: Tuple[int, int], defender: Player) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸä½ç½®ãŒç›¸æ‰‹ã‹ã‚‰æ”»æ’ƒã‚’å—ã‘ã¦ã„ã‚‹ã‹ç¢ºèª"""
        attacker = defender.opponent

        # ç›¸æ‰‹ã®ã™ã¹ã¦ã®é§’ã‚’ãƒã‚§ãƒƒã‚¯
        for row in range(BOARD_SIZE):
            for col in range(BOARD_SIZE):
                if self.board.is_occupied((row, col)):
                    piece = self.board.get_top_piece((row, col))
                    if piece and piece.owner == attacker:
                        # ã“ã®é§’ãŒç›®æ¨™ä½ç½®ã«ç§»å‹•ã§ãã‚‹ã‹ç¢ºèª
                        stack_level = self.board.get_top_stack_level((row, col))
                        possible_moves = piece.get_possible_moves((row, col), self.board, stack_level)
                        if position in possible_moves:
                            return True

        return False

    def is_game_over(self) -> bool:
      """ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ãŸã‹ã©ã†ã‹ã‚’ç¢ºèª"""
      return self.get_winner() is not None

    def get_winner(self) -> Optional[Player]:
        """ã‚²ãƒ¼ãƒ ã®å‹è€…ã‚’è¿”ã™ï¼ˆã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¦ã„ãªã„å ´åˆã¯Noneï¼‰"""
        # å¸¥ãŒå–ã‚‰ã‚ŒãŸå ´åˆ
        if hasattr(self, '_winner') and self._winner is not None:
            return self._winner

        # æŠ•äº†ã«ã‚ˆã‚‹å‹åˆ©
        if hasattr(self, '_resigned_player'):
            return self._resigned_player.opponent

        # è©°ã¿ã«ã‚ˆã‚‹å‹åˆ©
        if self.is_checkmate():
            return self.current_player.opponent

        return None

    def __str__(self):
        """ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã™"""
        result = []
        result.append(f"ç¾åœ¨ã®æ‰‹ç•ª: {'é»’ï¼ˆå…ˆæ‰‹ï¼‰' if self.current_player == Player.BLACK else 'ç™½ï¼ˆå¾Œæ‰‹ï¼‰'}")
        result.append(f"ãƒ•ã‚§ãƒ¼ã‚º: {'ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—' if self.phase == GamePhase.SETUP else 'ãƒ—ãƒ¬ã‚¤'}")

        if self.phase == GamePhase.SETUP:
            result.append(f"ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†: é»’={self.setup_complete[Player.BLACK]}, ç™½={self.setup_complete[Player.WHITE]}")

        result.append("\nç›¤é¢:")
        result.append(str(self.board))

        result.append("\næœªé…ç½®ã®é§’:")
        for player, name in [(Player.BLACK, "é»’ï¼ˆå…ˆæ‰‹ï¼‰"), (Player.WHITE, "ç™½ï¼ˆå¾Œæ‰‹ï¼‰")]:
            result.append(f"{name}:")
            for piece_type, count in self.players[player].unplaced_pieces.items():
                if count > 0:
                    piece_names = {
                        PieceType.SUI: "å¸¥",
                        PieceType.DAI: "å¤§",
                        PieceType.CHUU: "ä¸­",
                        PieceType.SHO: "å°",
                        PieceType.SAMURAI: "ä¾",
                        PieceType.HYO: "å…µ",
                        PieceType.UMA: "é¦¬",
                        PieceType.SHINOBI: "å¿",
                        PieceType.YARI: "æ§",
                        PieceType.TORIDE: "ç ¦",
                        PieceType.YUMI: "å¼“",
                        PieceType.TSUTU: "ç­’",
                        PieceType.HOU: "ç ²",
                        PieceType.BOU: "è¬€"
                    }
                    result.append(f"  {piece_names[piece_type]}: {count}å€‹")

        return "\n".join(result)

class GungiUI:
    """Google Colabã§è»è­°ã‚’ãƒ—ãƒ¬ã‚¤ã™ã‚‹ãŸã‚ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹"""
    def __init__(self):
        self.game = Game()
        self.selected_position = None
        self.message = "è»è­°ã¸ã‚ˆã†ã“ãï¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚º: ã¾ãšå¸¥ï¼ˆç‹ï¼‰ã‚’é…ç½®ã—ã¦ãã ã•ã„ã€‚"

        # ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        self.setup_widgets()

    def setup_widgets(self):
        """ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        self.output = widgets.Output()

        # ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã®é§’é¸æŠã®ãŸã‚ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        piece_options = []
        piece_names = {
            PieceType.SUI: "å¸¥ï¼ˆç‹ï¼‰",
            PieceType.DAI: "å¤§ï¼ˆé£›è»Š+æ–œã‚ï¼‰",
            PieceType.CHUU: "ä¸­ï¼ˆè§’è¡Œ+ç›´ç·šï¼‰",
            PieceType.SHO: "å°ï¼ˆé‡‘å°†ï¼‰",
            PieceType.SAMURAI: "ä¾",
            PieceType.HYO: "å…µï¼ˆå‰å¾Œæ­©å…µï¼‰",
            PieceType.UMA: "é¦¬ï¼ˆ2ãƒã‚¹ç›´ç·šï¼‰",
            PieceType.SHINOBI: "å¿ï¼ˆæ–œã‚1-2ãƒã‚¹ï¼‰",
            PieceType.YARI: "æ§ï¼ˆä¾+å‰2ãƒã‚¹ï¼‰",
            PieceType.TORIDE: "ç ¦ï¼ˆé˜²å¾¡é§’ï¼‰",
            PieceType.YUMI: "å¼“ï¼ˆé£›ã³è¶Šãˆï¼‰",
            PieceType.TSUTU: "ç­’ï¼ˆé£›ã³è¶Šãˆï¼‰",
            PieceType.HOU: "ç ²ï¼ˆé£›ã³è¶Šãˆï¼‰",
            PieceType.BOU: "è¬€ï¼ˆã‚¹ãƒ‘ã‚¤ï¼‰"
        }
        for pt in PieceType:
            piece_options.append((piece_names[pt], pt))

        self.piece_selector = widgets.Dropdown(
            options=piece_options,
            description='é§’:',
            disabled=False,
        )

        # ä½ç½®å…¥åŠ›
        self.row_input = widgets.BoundedIntText(
            value=0,
            min=0,
            max=8,
            description='è¡Œ:',
            disabled=False
        )

        self.col_input = widgets.BoundedIntText(
            value=0,
            min=0,
            max=8,
            description='åˆ—:',
            disabled=False
        )

        # ç•°ãªã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã®ãƒœã‚¿ãƒ³
        self.place_button = widgets.Button(description="é§’ã‚’é…ç½®")
        self.place_button.on_click(self.on_place_piece)

        self.done_button = widgets.Button(description="é…ç½®å®Œäº†")
        self.done_button.on_click(self.on_done_setup)

        self.select_button = widgets.Button(description="é§’ã‚’é¸æŠ")
        self.select_button.on_click(self.on_select_position)

        self.move_button = widgets.Button(description="ç§»å‹•å…ˆã‚’æŒ‡å®š")
        self.move_button.on_click(self.on_move_to_position)

        self.place_new_button = widgets.Button(description="æ–°ã—ã„é§’ã‚’é…ç½®")
        self.place_new_button.on_click(self.on_place_new_piece)

        # ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
        self.controls = widgets.VBox([
            widgets.HBox([self.row_input, self.col_input]),
            self.piece_selector,
            widgets.HBox([self.place_button, self.done_button]),
            widgets.HBox([self.select_button, self.move_button, self.place_new_button])
        ])

        # UIã®æ›´æ–°
        self.update_ui()

    def update_ui(self):
        """ç¾åœ¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’åæ˜ ã™ã‚‹ãŸã‚ã«UIã‚’æ›´æ–°"""
        with self.output:
            clear_output(wait=True)

            # ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¦ã„ã‚‹ã‹ç¢ºèª
            winner = self.game.get_winner()
            if winner:
                # å‹è€…ã‚’è¡¨ç¤ºã™ã‚‹ç‰¹åˆ¥ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                winner_text = "é»’ï¼ˆå…ˆæ‰‹ï¼‰" if winner == Player.BLACK else "ç™½ï¼ˆå¾Œæ‰‹ï¼‰"
                print(self.message)
                print("\n" + "=" * 40)
                print(f"å‹è€…: {winner_text}")
                print("=" * 40 + "\n")
            else:
                print(self.message)

            print(self.game)

            if self.selected_position:
                row, col = self.selected_position
                print(f"\né¸æŠã•ã‚ŒãŸä½ç½®: ({row}, {col})")

            # ã‚²ãƒ¼ãƒ çµ‚äº†ã—ãŸå ´åˆã®UIèª¿æ•´
            if self.game.get_winner():
                self.place_button.disabled = True
                self.done_button.disabled = True
                self.select_button.disabled = True
                self.move_button.disabled = True
                self.place_new_button.disabled = True
                if hasattr(self, 'resign_button'):
                    self.resign_button.disabled = True
            else:
                # é€šå¸¸ã®ã‚²ãƒ¼ãƒ ãƒ•ã‚§ãƒ¼ã‚ºã«åŸºã¥ãæœ‰åŠ¹/ç„¡åŠ¹åŒ–
                if self.game.phase == GamePhase.SETUP:
                    self.place_button.disabled = False
                    self.done_button.disabled = False
                    self.select_button.disabled = True
                    self.move_button.disabled = True
                    self.place_new_button.disabled = True
                    if hasattr(self, 'resign_button'):
                        self.resign_button.disabled = False
                else:  # GamePhase.PLAY
                    self.place_button.disabled = True
                    self.done_button.disabled = True
                    self.select_button.disabled = False
                    self.move_button.disabled = self.selected_position is None
                    self.place_new_button.disabled = False
                    if hasattr(self, 'resign_button'):
                        self.resign_button.disabled = False

    # GungiUI ã‚¯ãƒ©ã‚¹ã® on_place_piece ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£
    def on_place_piece(self, button):
        """ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¸­ã®é§’ã®é…ç½®ã‚’å‡¦ç†"""
        if self.game.phase != GamePhase.SETUP:
            self.message = "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºå¾Œã¯é§’ã‚’é…ç½®ã§ãã¾ã›ã‚“ã€‚"
            self.update_ui()
            return

        position = (self.row_input.value, self.col_input.value)
        piece_type = self.piece_selector.value

        # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
        print(f"é…ç½®è©¦è¡Œ: {position} ã« {piece_type.name}, ç¾åœ¨ã®æ‰‹ç•ª: {'é»’' if self.game.current_player == Player.BLACK else 'ç™½'}")

        success = self.game.place_piece(position, piece_type)

        if success:
            self.message = f"{position}ã«{piece_type.name}ã‚’é…ç½®ã—ã¾ã—ãŸã€‚"
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            print(f"é…ç½®æˆåŠŸ: æ¬¡ã®æ‰‹ç•ª: {'é»’' if self.game.current_player == Player.BLACK else 'ç™½'}")
            # æœ€åˆã®ã‚¿ãƒ¼ãƒ³ã®å¾Œã€æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å¸¥ã‚’é…ç½®ã™ã‚‹ã‚ˆã†ä¿ƒã™
            if self.game.move_count == 1:
                self.message += " ç™½ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€å¸¥ï¼ˆç‹ï¼‰ã‚’é…ç½®ã—ã¦ãã ã•ã„ã€‚"
        else:
            self.message = f"{position}ã«{piece_type.name}ã‚’é…ç½®ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            print(f"é…ç½®å¤±æ•—: ç†ç”±ã‚’ç¢ºèª")

        self.update_ui()

    def on_done_setup(self, button):
        """ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºã®å®Œäº†ã‚’å‡¦ç†"""
        if self.game.phase != GamePhase.SETUP:
            self.message = "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºã¯ã™ã§ã«å®Œäº†ã—ã¦ã„ã¾ã™ã€‚"
            self.update_ui()
            return

        success = self.game.declare_setup_complete()

        if success:
            if self.game.phase == GamePhase.PLAY:
                self.message = "ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Œäº†ã—ã¾ã—ãŸã€‚ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºãŒå§‹ã¾ã‚Šã¾ã™ï¼"
            else:
                self.message = f"{'é»’' if self.game.current_player == Player.BLACK else 'ç™½'}ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Œäº†ã—ã¦ãã ã•ã„ã€‚"
        else:
            self.message = "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Œäº†ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"

        self.update_ui()

    def on_select_position(self, button):
        """ç›¤é¢ä¸Šã®ä½ç½®ã®é¸æŠã‚’å‡¦ç†"""
        if self.game.phase != GamePhase.PLAY:
            self.message = "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã¯ä½ç½®ã‚’é¸æŠã§ãã¾ã›ã‚“ã€‚"
            self.update_ui()
            return

        position = (self.row_input.value, self.col_input.value)

        if not self.game.board.is_occupied(position):
            self.message = "ãã®ä½ç½®ã«é§’ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚"
            self.selected_position = None
        else:
            top_piece = self.game.board.get_top_piece(position)
            if top_piece.owner != self.game.current_player:
                self.message = "ãã®é§’ã¯ç›¸æ‰‹ã®ã‚‚ã®ã§ã™ã€‚"
                self.selected_position = None
            else:
                self.selected_position = position
                stack_level = self.game.board.get_top_stack_level(position)
                possible_moves = top_piece.get_possible_moves(position, self.game.board, stack_level)
                self.message = f"{position}ã®{top_piece.piece_type.name}ã‚’é¸æŠã—ã¾ã—ãŸã€‚å¯èƒ½ãªç§»å‹•å…ˆ: {possible_moves}"

        self.update_ui()

    def on_move_to_position(self, button):
        """é§’ã‚’æ–°ã—ã„ä½ç½®ã«ç§»å‹•ã•ã›ã‚‹å‡¦ç†"""
        if self.game.phase != GamePhase.PLAY:
            self.message = "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã¯é§’ã‚’ç§»å‹•ã§ãã¾ã›ã‚“ã€‚"
            self.update_ui()
            return

        if self.selected_position is None:
            self.message = "ã¾ãšç§»å‹•ã™ã‚‹é§’ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚"
            self.update_ui()
            return

        to_position = (self.row_input.value, self.col_input.value)

        # ç§»å‹•å…ˆã«æ•µã®å¸¥ãŒã‚ã‚‹ã‹ç¢ºèª
        target_is_enemy_sui = False
        if self.game.board.is_occupied(to_position):
            target_piece = self.game.board.get_top_piece(to_position)
            if target_piece and target_piece.owner != self.game.current_player and target_piece.piece_type == PieceType.SUI:
                target_is_enemy_sui = True

        success = self.game.move_piece(self.selected_position, to_position)

        if success:
            self.message = f"{self.selected_position}ã‹ã‚‰{to_position}ã«é§’ã‚’ç§»å‹•ã—ã¾ã—ãŸã€‚"
            self.selected_position = None

            # å‹åˆ©æ¡ä»¶ã‚’ç¢ºèª
            winner = self.game.get_winner()
            if winner:
                winner_text = "é»’ï¼ˆå…ˆæ‰‹ï¼‰" if winner == Player.BLACK else "ç™½ï¼ˆå¾Œæ‰‹ï¼‰"
                if target_is_enemy_sui:
                    self.message = f"ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ {winner_text}ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç›¸æ‰‹ã®å¸¥ã‚’å–ã‚Šã¾ã—ãŸï¼{winner_text}ã®å‹åˆ©ã§ã™ï¼"
                else:
                    self.message = f"ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ {winner_text}ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©ã§ã™ï¼ç›¸æ‰‹ã®å¸¥ãŒè©°ã¿ã¾ã—ãŸï¼"
        else:
            self.message = f"{self.selected_position}ã‹ã‚‰{to_position}ã«ç§»å‹•ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"

        self.update_ui()

    def on_place_new_piece(self, button):
        """ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã®æ–°ã—ã„é§’ã®é…ç½®ã‚’å‡¦ç†"""
        if self.game.phase != GamePhase.PLAY:
            self.message = "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã¯æ–°ã—ã„é§’ã‚’é…ç½®ã§ãã¾ã›ã‚“ã€‚"
            self.update_ui()
            return

        position = (self.row_input.value, self.col_input.value)
        piece_type = self.piece_selector.value

        success = self.game.place_new_piece(position, piece_type)

        if success:
            self.message = f"{position}ã«æ–°ã—ã„{piece_type.name}ã‚’é…ç½®ã—ã¾ã—ãŸã€‚"
        else:
            self.message = f"{position}ã«æ–°ã—ã„{piece_type.name}ã‚’é…ç½®ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"

        self.update_ui()

    def display(self):
        """ãƒ¡ã‚¤ãƒ³UIã‚’è¡¨ç¤º"""
        return widgets.VBox([self.controls, self.output])


def start_gungi_game():
    """æ–°ã—ã„è»è­°ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹"""
    ui = GungiUI()
    display(ui.display())
    return ui


# é§’ã‚¿ã‚¤ãƒ—ã‚’ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰è¨˜å·ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
def get_piece_symbol(piece_type, player):
    """é§’ã‚¿ã‚¤ãƒ—ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å¯¾å¿œã™ã‚‹ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰è¨˜å·ã‚’è¿”ã™"""
    black_symbols = {
        PieceType.SUI: "â™š",     # ç‹
        PieceType.DAI: "â™œ",     # é£›è»Š
        PieceType.CHUU: "â™",    # è§’è¡Œ
        PieceType.SHO: "â™",     # é‡‘å°†
        PieceType.SAMURAI: "â›©ï¸",  # ä¾
        PieceType.HYO: "â™Ÿ",     # æ­©å…µ
        PieceType.UMA: "ğŸ",     # é¦¬
        PieceType.SHINOBI: "ğŸ‘¥",  # å¿è€…
        PieceType.YARI: "âš”ï¸",     # æ§
        PieceType.TORIDE: "ğŸ¯",   # ç ¦
        PieceType.YUMI: "ğŸ¹",     # å¼“
        PieceType.TSUTU: "ğŸ”«",    # ç­’
        PieceType.HOU: "ğŸ’£",     # ç ²
        PieceType.BOU: "ğŸ•µï¸",     # è¬€
    }

    white_symbols = {
        PieceType.SUI: "â™”",     # ç‹
        PieceType.DAI: "â™–",     # é£›è»Š
        PieceType.CHUU: "â™—",    # è§’è¡Œ
        PieceType.SHO: "â™˜",     # é‡‘å°†
        PieceType.SAMURAI: "â›©ï¸",  # ä¾
        PieceType.HYO: "â™™",     # æ­©å…µ
        PieceType.UMA: "ğŸ",     # é¦¬
        PieceType.SHINOBI: "ğŸ‘¥",  # å¿è€…
        PieceType.YARI: "âš”ï¸",     # æ§
        PieceType.TORIDE: "ğŸ¯",   # ç ¦
        PieceType.YUMI: "ğŸ¹",     # å¼“
        PieceType.TSUTU: "ğŸ”«",    # ç­’
        PieceType.HOU: "ğŸ’£",     # ç ²
        PieceType.BOU: "ğŸ•µï¸",     # è¬€
    }

    return black_symbols[piece_type] if player == Player.BLACK else white_symbols[piece_type]


# å°†æ¥ã®å®Ÿè£…ã®ãŸã‚ã®AIå¯¾æˆ¦ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
class AIPlayer:
    """AIå¯¾æˆ¦ç›¸æ‰‹ã®åŸºæœ¬ã‚¯ãƒ©ã‚¹"""
    def __init__(self, color: Player, difficulty: str = "easy"):
        self.color = color
        self.difficulty = difficulty
        self.unplaced_pieces = {}

        # æœªé…ç½®ã®é§’ã‚»ãƒƒãƒˆã‚’åˆæœŸåŒ–
        for piece_type, count in PIECE_COUNTS.items():
            self.unplaced_pieces[piece_type] = count

    def get_unplaced_count(self, piece_type: PieceType) -> int:
        """æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã®æ•°ã‚’è¿”ã™"""
        return self.unplaced_pieces.get(piece_type, 0)

    def decrement_unplaced(self, piece_type: PieceType) -> bool:
        """æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã®æ•°ã‚’æ¸›ã‚‰ã™"""
        if self.get_unplaced_count(piece_type) <= 0:
            return False
        self.unplaced_pieces[piece_type] -= 1
        return True

    def increment_unplaced(self, piece_type: PieceType) -> None:
        """æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®æœªé…ç½®é§’ã®æ•°ã‚’å¢—ã‚„ã™"""
        self.unplaced_pieces[piece_type] = self.get_unplaced_count(piece_type) + 1

    def has_spy_conversion_available(self, enemy_piece_type: PieceType) -> bool:
        """ã‚¹ãƒ‘ã‚¤å¤‰æ›ã«ä½¿ç”¨å¯èƒ½ãªæœªé…ç½®é§’ãŒã‚ã‚‹ã‹ç¢ºèª"""
        return self.get_unplaced_count(enemy_piece_type) > 0

    def make_setup_move(self, game: Game) -> Tuple[Union[Tuple[int, int], None], Union[PieceType, None], bool]:
        """ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«ç§»å‹•ã‚’è¡Œã†

        æˆ»ã‚Šå€¤:
            (ä½ç½®, é§’ã‚¿ã‚¤ãƒ—, å®Œäº†ãƒ•ãƒ©ã‚°)ã®ã‚¿ãƒ—ãƒ«
            å®Œäº†ãƒ•ãƒ©ã‚°ãŒTrueã®å ´åˆã€AIã¯ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Œäº†ã—ãŸ
        """
        # å…·ä½“çš„ãªAIã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ã•ã‚Œã‚‹
        raise NotImplementedError

    def make_play_move(self, game: Game) -> Union[Tuple[Tuple[int, int], Tuple[int, int]], Tuple[Tuple[int, int], PieceType]]:
        """ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«ç§»å‹•ã‚’è¡Œã†

        æˆ»ã‚Šå€¤:
            é§’ã‚’ç§»å‹•ã™ã‚‹å ´åˆã¯ (from_pos, to_pos)
            æ–°ã—ã„é§’ã‚’é…ç½®ã™ã‚‹å ´åˆã¯ (position, piece_type)
        """
        # å…·ä½“çš„ãªAIã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ã•ã‚Œã‚‹
        raise NotImplementedError


class RandomAI(AIPlayer):
    """åˆæ³•æ‰‹ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶ã‚·ãƒ³ãƒ—ãƒ«ãªAI"""
    def make_setup_move(self, game: Game) -> Tuple[Union[Tuple[int, int], None], Union[PieceType, None], bool]:
        """ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«ãƒ©ãƒ³ãƒ€ãƒ ãªæ‰‹ã‚’æŒ‡ã™"""
        # æœ€åˆã®æ‰‹ã¯å¿…ãšå¸¥ï¼ˆç‹ï¼‰ã‚’é…ç½®
        if game.move_count == 0 or (game.move_count == 1 and game.current_player == Player.WHITE):
            piece_type = PieceType.SUI

            # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é ˜åŸŸå†…ã®ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã‚’é¸æŠ
            if self.color == Player.BLACK:
                row = np.random.randint(6, 9)  # é»’ã®é ˜åŸŸ
            else:
                # ç™½ã¯å…·ä½“çš„ã«æŒ‡å®šï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’æ¸›ã‚‰ã™ï¼‰
                row = np.random.randint(0, 3)  # ç™½ã®é ˜åŸŸ

            col = np.random.randint(0, 9)

            print(f"AI: å¸¥ã‚’é…ç½®ã—ã¾ã™ - ä½ç½®: ({row}, {col})")
            return ((row, col), piece_type, False)

        # é§’ã‚’é…ç½®ã™ã‚‹ã‹ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã‚’å®£è¨€ã™ã‚‹ã‹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
        if np.random.random() < 0.9:  # 90%ã®ç¢ºç‡ã§é§’ã‚’é…ç½®
            # ã¾ã åˆ©ç”¨å¯èƒ½ãªé§’ã‚¿ã‚¤ãƒ—ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
            available_types = [pt for pt in PieceType if self.get_unplaced_count(pt) > 0]
            if not available_types:
                print("AI: é…ç½®å¯èƒ½ãªé§’ãŒãªã„ãŸã‚ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã‚’å®£è¨€ã—ã¾ã™")
                return (None, None, True)  # é§’ãŒæ®‹ã£ã¦ã„ãªã„å ´åˆã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†

            piece_type = np.random.choice(available_types)

            # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é ˜åŸŸå†…ã®ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã‚’é¸æŠ
            if self.color == Player.BLACK:
                row = np.random.randint(6, 9)  # é»’ã®é ˜åŸŸ
            else:
                row = np.random.randint(0, 3)  # ç™½ã®é ˜åŸŸ

            col = np.random.randint(0, 9)

            # ä½ç½®ãŒæ—¢ã«å æœ‰ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            attempts = 0
            max_attempts = 50  # æœ€å¤§è©¦è¡Œå›æ•°
            while game.board.is_occupied((row, col)) and attempts < max_attempts:
                # åˆ¥ã®ä½ç½®ã‚’è©¦ã™
                if self.color == Player.BLACK:
                    row = np.random.randint(6, 9)
                else:
                    row = np.random.randint(0, 3)
                col = np.random.randint(0, 9)
                attempts += 1

            if attempts >= max_attempts:
                print("AI: ç©ºãã‚¹ãƒšãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã‚’å®£è¨€ã—ã¾ã™")
                return (None, None, True)

            print(f"AI: {piece_type.name}ã‚’é…ç½®ã—ã¾ã™ - ä½ç½®: ({row}, {col})")
            return ((row, col), piece_type, False)
        else:
            # ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã‚’å®£è¨€
            print("AI: ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã‚’å®£è¨€ã—ã¾ã™")
            return (None, None, True)


    def make_play_move(self, game: Game) -> Union[Tuple[Tuple[int, int], Tuple[int, int]], Tuple[Tuple[int, int], PieceType]]:
        """ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã«ãƒ©ãƒ³ãƒ€ãƒ ãªåˆæ³•æ‰‹ã‚’æŒ‡ã™"""
        # å¯èƒ½ãªå…¨ã¦ã®æ‰‹ã‚’åé›†
        possible_moves = []

        # æ—¢å­˜ã®é§’ã®ç§»å‹•
        for row in range(BOARD_SIZE):
            for col in range(BOARD_SIZE):
                position = (row, col)
                if game.board.is_occupied(position):
                    piece = game.board.get_top_piece(position)
                    if piece.owner == self.color:
                        stack_level = game.board.get_top_stack_level(position)
                        moves = piece.get_possible_moves(position, game.board, stack_level)
                        for to_pos in moves:
                            possible_moves.append(("move", position, to_pos))

        # æ–°ã—ã„é§’ã®é…ç½®
        for piece_type in PieceType:
            if self.get_unplaced_count(piece_type) > 0:
                frontline = game.get_frontline(self.color)

                for col in range(BOARD_SIZE):
                    if self.color == Player.BLACK:
                        # é»’ã®é§’ã¯å‰ç·šä»¥é™ã«é…ç½®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                        valid_rows = range(frontline, BOARD_SIZE)
                    else:
                        # ç™½ã®é§’ã¯å‰ç·šä»¥é™ã«é…ç½®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                        valid_rows = range(0, frontline + 1)

                    for row in valid_rows:
                        position = (row, col)
                        if not game.board.is_occupied(position):
                            possible_moves.append(("place", position, piece_type))

        # ãƒ©ãƒ³ãƒ€ãƒ ãªæ‰‹ã‚’é¸æŠ - NumPyã®random.choiceã§ã¯ãªãPythonã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
        if possible_moves:
            import random
            move = random.choice(possible_moves)
            move_type = move[0]

            if move_type == "move":
                from_pos, to_pos = move[1], move[2]
                return (from_pos, to_pos)
            else:  # "place"
                position, piece_type = move[1], move[2]
                return (position, piece_type)

        # åˆæ³•æ‰‹ãŒãªã„
        return None

class GungiGameWithAI:
    """AIã¨ã®å¯¾æˆ¦ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹æ‹¡å¼µã‚²ãƒ¼ãƒ ã‚¯ãƒ©ã‚¹"""
    def __init__(self, black_player="human", white_player="human", ai_difficulty="easy"):
        self.game = Game()

        # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        if black_player == "human":
            self.black_player = HumanPlayer(Player.BLACK)
        else:
            self.black_player = RandomAI(Player.BLACK, difficulty=ai_difficulty)

        if white_player == "human":
            self.white_player = HumanPlayer(Player.WHITE)
        else:
            self.white_player = RandomAI(Player.WHITE, difficulty=ai_difficulty)

        self.game.players = {
            Player.BLACK: self.black_player,
            Player.WHITE: self.white_player
        }

        self.ui = None

    def get_current_player_type(self):
        """ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒäººé–“ã‹AIã‹ã‚’è¿”ã™"""
        if self.game.current_player == Player.BLACK:
            return "human" if isinstance(self.black_player, HumanPlayer) else "ai"
        else:
            return "human" if isinstance(self.white_player, HumanPlayer) else "ai"

    def make_ai_move(self):
        """AI ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹ã‚’æŒ‡ã™"""
        if self.game.get_winner():
            print("ã‚²ãƒ¼ãƒ ã¯æ—¢ã«çµ‚äº†ã—ã¦ã„ã¾ã™")
            return

        ai_player = self.game.players[self.game.current_player]

        if self.game.phase == GamePhase.SETUP:
            print(f"AIï¼ˆ{'é»’' if self.game.current_player == Player.BLACK else 'ç™½'}ï¼‰: ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚ºã®æ‰‹ã‚’è€ƒãˆã¦ã„ã¾ã™...")
            position, piece_type, done_flag = ai_player.make_setup_move(self.game)

            if done_flag:
                print("AI: ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ã‚’å®£è¨€ã—ã¾ã™")
                success = self.game.declare_setup_complete()
                if not success:
                    print("AIã¯ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Œäº†ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
            elif position and piece_type:
                print(f"AI: {position}ã«{piece_type.name}ã‚’é…ç½®ã—ã¾ã™")
                success = self.game.place_piece(position, piece_type)
                if success:
                    print(f"AI: {position}ã«{piece_type.name}ã®é…ç½®ã«æˆåŠŸã—ã¾ã—ãŸ")
                else:
                    print(f"AIã¯{position}ã«{piece_type.name}ã‚’é…ç½®ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
        else:  # GamePhase.PLAY
            print(f"AIï¼ˆ{'é»’' if self.game.current_player == Player.BLACK else 'ç™½'}ï¼‰: ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚ºã®æ‰‹ã‚’è€ƒãˆã¦ã„ã¾ã™...")
            move = ai_player.make_play_move(self.game)

            if move:
                if isinstance(move[1], PieceType):
                    # æ–°ã—ã„é§’ã‚’é…ç½®
                    position, piece_type = move
                    success = self.game.place_new_piece(position, piece_type)
                    if success:
                        print(f"AI: {position}ã«æ–°ã—ã„{piece_type.name}ã®é…ç½®ã«æˆåŠŸã—ã¾ã—ãŸ")
                    else:
                        print(f"AIã¯{position}ã«æ–°ã—ã„{piece_type.name}ã‚’é…ç½®ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
                else:
                    # é§’ã‚’ç§»å‹•
                    from_pos, to_pos = move
                    success = self.game.move_piece(from_pos, to_pos)
                    if success:
                        print(f"AI: {from_pos}ã‹ã‚‰{to_pos}ã¸ã®ç§»å‹•ã«æˆåŠŸã—ã¾ã—ãŸ")
                    else:
                        print(f"AIã¯{from_pos}ã‹ã‚‰{to_pos}ã«ç§»å‹•ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")


    def update_ui(self):
        """AIç§»å‹•å¾Œã«UIã‚’æ›´æ–°"""
        if self.ui:
            self.ui.update_ui()

    def start_game(self):
        """ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—UIã‚’ä½œæˆ"""
        self.ui = GungiUIWithAI(self)
        display(self.ui.display())

        # æœ€åˆã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒAIãªã‚‰ã€æ‰‹ã‚’æŒ‡ã™
        if self.get_current_player_type() == "ai":
            print("æœ€åˆã®æ‰‹ã¯AIãŒæŒ‡ã—ã¾ã™...")
            self.make_ai_move()
            self.ui.update_ui()


class GungiUIWithAI(GungiUI):
    """AIã¨ã®å¯¾æˆ¦ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹æ‹¡å¼µUIã‚¯ãƒ©ã‚¹"""
    def __init__(self, game_with_ai):
        self.game_with_ai = game_with_ai
        self.game = game_with_ai.game
        self.selected_position = None
        self.message = "è»è­°ã¸ã‚ˆã†ã“ãï¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚º: ã¾ãšå¸¥ï¼ˆç‹ï¼‰ã‚’é…ç½®ã—ã¦ãã ã•ã„ã€‚"

        # ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        self.setup_widgets()

    def update_ui(self):
        """ç¾åœ¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’åæ˜ ã™ã‚‹ãŸã‚ã«UIã‚’æ›´æ–°"""
        super().update_ui()

        # ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¦ã„ã‚‹å ´åˆã¯AIã‚’å‹•ã‹ã•ãªã„
        if self.game.get_winner():
            return

        # AIã®ç•ªãªã‚‰ã€æ‰‹ã‚’æŒ‡ã™
        if self.game_with_ai.get_current_player_type() == "ai":
            self.message = "AIãŒè€ƒãˆã¦ã„ã¾ã™..."
            with self.output:
                clear_output(wait=True)
                print(self.message)
                print(self.game)

            # AI ã®æ‰‹ã‚’å®Ÿè¡Œ
            try:
                print("AIãŒè¡Œå‹•ã‚’é¸æŠä¸­...")
                self.game_with_ai.make_ai_move()
                print("AIè¡Œå‹•å®Œäº†")
            except Exception as e:
                print(f"AIã‚¨ãƒ©ãƒ¼: {str(e)}")
                import traceback
                traceback.print_exc()

            # å‹åˆ©æ¡ä»¶ã‚’ç¢ºèª
            winner = self.game.get_winner()
            if winner:
                winner_text = "é»’ï¼ˆå…ˆæ‰‹ï¼‰" if winner == Player.BLACK else "ç™½ï¼ˆå¾Œæ‰‹ï¼‰"
                if hasattr(self.game, '_captured_sui') and self.game._captured_sui:
                    self.message = f"ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ {winner_text}ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆAIï¼‰ãŒç›¸æ‰‹ã®å¸¥ã‚’å–ã‚Šã¾ã—ãŸï¼{winner_text}ã®å‹åˆ©ã§ã™ï¼"
                else:
                    self.message = f"ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ {winner_text}ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆAIï¼‰ã®å‹åˆ©ã§ã™ï¼ç›¸æ‰‹ã®å¸¥ãŒè©°ã¿ã¾ã—ãŸï¼"
            else:
                self.message = "AIãŒæ‰‹ã‚’æŒ‡ã—ã¾ã—ãŸã€‚ã‚ãªãŸã®ç•ªã§ã™ã€‚"

            # æ›´æ–°ã—ãŸç›¤é¢ã‚’è¡¨ç¤º
            with self.output:
                clear_output(wait=True)
                print(self.message)
                print(self.game)


def start_gungi_game_vs_ai(black_player="human", white_player="ai", ai_difficulty="easy"):
    """Colabã§AIå¯¾æˆ¦ã®æ–°ã—ã„è»è­°ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹"""
    game = GungiGameWithAI(black_player, white_player, ai_difficulty)
    game.start_game()
    return game


# ä½¿ç”¨æ–¹æ³•èª¬æ˜
def gungi_help():
    """è»è­°ã®ãƒ—ãƒ¬ã‚¤æ–¹æ³•ã«é–¢ã™ã‚‹ãƒ˜ãƒ«ãƒ—æƒ…å ±ã‚’è¡¨ç¤º"""
    help_text = """
    # è»è­° - ãƒ—ãƒ¬ã‚¤æ–¹æ³•

    ## ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ•ã‚§ãƒ¼ã‚º
    1. å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯äº¤äº’ã«ç›¤é¢ã®è‡ªåˆ†å´ã«é§’ã‚’é…ç½®ã—ã¾ã™ã€‚
    2. ã¾ãšã€å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å¸¥ï¼ˆç‹ï¼‰é§’ã‚’é…ç½®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
    3. é§’ã‚’é…ç½®ã—ãŸå¾Œã€ã€Œé…ç½®å®Œäº†ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’çµ‚äº†ã—ã¾ã™ã€‚
    4. ä¸¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’å®Œäº†ã™ã‚‹ã¨ã‚²ãƒ¼ãƒ ãŒå§‹ã¾ã‚Šã¾ã™ã€‚

    ## ãƒ—ãƒ¬ã‚¤ãƒ•ã‚§ãƒ¼ã‚º
    1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯äº¤äº’ã«é§’ã‚’ç§»å‹•ã™ã‚‹ã‹ã€äºˆå‚™ã‹ã‚‰æ–°ã—ã„é§’ã‚’é…ç½®ã—ã¾ã™ã€‚
    2. é§’ã‚’ç§»å‹•ã™ã‚‹ã«ã¯:
       - ã€Œé§’ã‚’é¸æŠã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é§’ã‚’é¸ã³ã¾ã™
       - ç§»å‹•å…ˆã®åº§æ¨™ã‚’å…¥åŠ›ã—ã¾ã™
       - ã€Œç§»å‹•å…ˆã‚’æŒ‡å®šã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™
    3. æ–°ã—ã„é§’ã‚’é…ç½®ã™ã‚‹ã«ã¯:
       - ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‹ã‚‰é§’ã®ã‚¿ã‚¤ãƒ—ã‚’é¸ã³ã¾ã™
       - åº§æ¨™ã‚’å…¥åŠ›ã—ã¾ã™
       - ã€Œæ–°ã—ã„é§’ã‚’é…ç½®ã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™

    ## å‹åˆ©æ¡ä»¶
    ç›¸æ‰‹ã®å¸¥ï¼ˆç‹ï¼‰é§’ã‚’è©°ã¾ã›ã‚‹ã“ã¨ãŒç›®æ¨™ã§ã™ã€‚

    ## é‡ã­é§’ã®ãƒ«ãƒ¼ãƒ«
    - é§’ã¯æœ€å¤§3æ®µã¾ã§ç©ã¿é‡ã­ã‚‹ã“ã¨ãŒã§ãã¾ã™
    - é«˜ã„ä½ç½®ã«ã‚ã‚‹é§’ã¯ä½ã„ä½ç½®ã®é§’ã«å¯¾ã—ã¦å„ªä½ã§ã™
    - è¬€ï¼ˆã‚¹ãƒ‘ã‚¤ï¼‰ã®ã‚ˆã†ãªç‰¹æ®Šé§’ã¯ç‰¹åˆ¥ãªèƒ½åŠ›ã‚’æŒã£ã¦ã„ã¾ã™

    é§’ã®å‹•ãã¨ç‰¹æ®Šãƒ«ãƒ¼ãƒ«ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
    """

    display(HTML(f"<div style='background-color:#f9f9f9; padding:15px; border-radius:5px;'><pre>{help_text}</pre></div>"))